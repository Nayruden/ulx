<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>sh_tablex.moon</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css" /><script type="text/javascript" src="../../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.0.2 -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="TableX"></a><a name="Topic139"></a><div class="CTopic TClass LMoonScript first">
 <div class="CTitle">TableX</div>
 <div class="CBody"><p>A static class used for table-specific utility functions that are not specific to Garry's Mod.</p></div>
</div>

<a name="TableX.Functions"></a><a name="Topic140"></a><div class="CTopic TGroup LMoonScript">
 <div class="CTitle">Functions</div>
</div>

<a name="TableX.Count"></a><a name="Topic141"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">Count</div>
 <div id="NDPrototype141" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@Count: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">t&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Counts the number of elements in a table using pairs.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">t</td><td class="CDLDefinition"><p>The <b>table</b> to count.</p></td></tr></table><div class="CHeading">Returns</div><p>The <b>number</b> of elements in the table.</p><div class="CHeading">Example</div><p>:Count( { &quot;apple&quot;, &quot;pear&quot;, done=true, banana=&quot;yellow&quot; } )</p><p>returns...</p><p>:4</p><div class="CHeading">Notes</div><ul><li><p>This is slow and should be avoided if at all possible.</p></li><li><p>Use the '#' operator instead of this if the table only contains numeric indices or if you only care about the numeric indices.</p></li><li><p>Use <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.IsEmpty" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,142);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >IsEmpty</a> instead of this if you only want to see if a hash table has any values.</p></li><li><p>Complexity is O(n), where n is the number of values in t.</p></li></ul></div>
</div>

<a name="TableX.IsEmpty"></a><a name="Topic142"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">IsEmpty</div>
 <div id="NDPrototype142" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@IsEmpty: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">t&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Checks if a table contains any values on any type of key.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">t</td><td class="CDLDefinition"><p>The <b>table</b> to check.</p></td></tr></table><div class="CHeading">Returns</div><p>A <b>boolean</b>, true if the table t has one or more values, false otherwise.</p><div class="CHeading">Notes</div><ul><li><p>This is much faster than <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.Count" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,141);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >Count</a> for checking if a table has any elements.</p></li><li><p>Complexity is O(1).</p></li></ul></div>
</div>

<a name="TableX.Empty"></a><a name="Topic143"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">Empty</div>
 <div id="NDPrototype143" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@Empty: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">t&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Removes all data from a table.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">t</td><td class="CDLDefinition"><p>The <b>table</b> to empty.</p></td></tr></table><div class="CHeading">Returns</div><p>The <b>table</b> t.</p><div class="CHeading">Notes</div><ul><li><p>Complexity is O(Count(t)).</p></li></ul></div>
</div>

<a name="TableX.Copy"></a><a name="Topic144"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">Copy</div>
 <div id="NDPrototype144" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@Copy: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">t&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Make a shallow copy of a table. A shallow copy means that any subtables will still refer to the	same underlying table.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">t</td><td class="CDLDefinition"><p>The <b>table</b> to make a copy of.</p></td></tr></table><div class="CHeading">Returns</div><p>The copied <b>table</b>.</p><div class="CHeading">Notes</div><ul><li><p>Complexity is O(Count(t)).</p></li></ul></div>
</div>

<a name="TableX.CopyI"></a><a name="Topic145"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">CopyI</div>
 <div id="NDPrototype145" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@CopyI: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">t&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Exactly the same as <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.Copy" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,144);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >Copy</a> except that it uses fori instead of pairs.&nbsp; In general, this means that it only copies numeric keys. See &lt;A Discussion On fori&gt;.</p></div>
</div>

<a name="TableX.DeepCopy"></a><a name="Topic146"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">DeepCopy</div>
 <div id="NDPrototype146" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@DeepCopy: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">t&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Make a deep copy of a table. A deep copy means that any subtables will refer to a new copy of the original subtable.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">t</td><td class="CDLDefinition"><p>The <b>table</b> to make a copy of. Must not have any cycles.</p></td></tr></table><div class="CHeading">Returns</div><p>The copied <b>table</b>.</p></div>
</div>

<a name="TableX.RemoveDuplicateValues"></a><a name="Topic147"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">RemoveDuplicateValues</div>
 <div id="NDPrototype147" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@RemoveDuplicateValues: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">list,</td></tr><tr><td class="PModifierQualifier first">inPlace&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Removes any duplicate values from a list.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">list</td><td class="CDLDefinition"><p>The <b>list</b> to remove duplicates from.</p></td></tr><tr><td class="CDLEntry">inPlace</td><td class="CDLDefinition"><p>An <b>optional boolean</b>, defaults to <u>false</u>. If true, all operations occur on list itself, rather than a copy.</p></td></tr></table><div class="CHeading">Returns</div><p>The <b>list</b> that was passed in with duplicates removed. Returns the original table reference if in_place is true, a new table otherwise.</p><div class="CHeading">Example</div><p>:RemoveDuplicateValues( { &quot;apple&quot;, &quot;pear&quot;, &quot;kiwi&quot;, &quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pear&quot; } )</p><p>returns...&nbsp; :{ &quot;apple&quot;, &quot;pear&quot;, &quot;kiwi&quot;, &quot;banana&quot; }</p><div class="CHeading">Notes</div><ul><li><p>This function operates over numeric indices. See &lt;A Discussion On fori&gt;.</p></li><li><p>Complexity is around O(#list * log( #list )).</p></li><li><p>Duplicates are removed after the first value occurs. See example above.</p></li></ul></div>
</div>

<a name="TableX.UnionByKey"></a><a name="Topic148"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">UnionByKey</div>
 <div id="NDPrototype148" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@UnionByKey: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">tableA,</td></tr><tr><td class="first"></td><td></td><td class="PName last">tableB,</td></tr><tr><td class="PModifierQualifier first">inPlace&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Merges two tables by key.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">tableA</td><td class="CDLDefinition"><p>The first <b>table</b> in the union.</p></td></tr><tr><td class="CDLEntry">tableB</td><td class="CDLDefinition"><p>The second <b>table</b> in the union.</p></td></tr><tr><td class="CDLEntry">inPlace</td><td class="CDLDefinition"><p>An <b>optional boolean</b>, defaults to <u>false</u>. If true, all operations occur on tableA itself, rather than a copy.</p></td></tr></table><div class="CHeading">Returns</div><p>The union <b>table</b>. Returns tableA if inPlace is true, a new table otherwise.</p><div class="CHeading">Example</div><p>:UnionByKey( { apple=&quot;red&quot;, pear=&quot;green&quot;, kiwi=&quot;hairy&quot; },</p><pre>{ apple=&quot;green&quot;, pear=&quot;green&quot;, banana=&quot;yellow&quot; } )</pre><p>returns...</p><p>:{ apple=&quot;green&quot;, pear=&quot;green&quot;, kiwi=&quot;hairy&quot;, banana=&quot;yellow&quot; }</p><div class="CHeading">Notes</div><ul><li><p>If both tables have values on the same key, tableB takes precedence.</p></li><li><p>Complexity is O(Count(tableB)).</p></li></ul></div>
</div>

<a name="TableX.UnionByKeyI"></a><a name="Topic149"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">UnionByKeyI</div>
 <div id="NDPrototype149" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@UnionByKeyI: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">tableA,</td></tr><tr><td class="first"></td><td></td><td class="PName last">tableB,</td></tr><tr><td class="PModifierQualifier first">inPlace&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Exactly the same as <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.UnionByKey" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,148);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >UnionByKey</a> except that it uses fori instead of pairs. In general, this means that it only merges on numeric keys. See &lt;A Discussion On fori&gt;.</p></div>
</div>

<a name="TableX.Union"></a><a name="Topic150"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">Union</div>
 <div id="NDPrototype150" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@Union: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">listA,</td></tr><tr><td class="first"></td><td></td><td class="PName last">listB,</td></tr><tr><td class="PModifierQualifier first">inPlace&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Gets the union of two lists by value. If a value occurs once in listA and once in listB, the result of the union will only have one instance of that value as well.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">listA</td><td class="CDLDefinition"><p>The first <b>list</b> in the union.</p></td></tr><tr><td class="CDLEntry">listB</td><td class="CDLDefinition"><p>The second <b>list</b> in the union.</p></td></tr><tr><td class="CDLEntry">inPlace</td><td class="CDLDefinition"><p>An <b>optional boolean</b>, defaults to <u>false</u>. If true, all operations occur on tableA itself, rather than a copy.</p></td></tr></table><div class="CHeading">Returns</div><p>The union <b>list</b>. Returns tableA if inPlace is true, a new table otherwise.</p><div class="CHeading">Example</div><p>:Union( { &quot;apple&quot;, &quot;pear&quot;, &quot;kiwi&quot; }, { &quot;pear&quot;, &quot;apple&quot;, &quot;banana&quot; } )</p><p>returns...</p><p>:{ &quot;apple&quot;, &quot;pear&quot;, &quot;kiwi&quot;, &quot;banana&quot; }</p><div class="CHeading">Notes</div><ul><li><p>This function operates over numeric indices. See &lt;A Discussion On fori&gt;.</p></li><li><p>The elements that in the returned table are in the same order they were in tableA and then tableB. See example above.</p></li><li><p>This function properly handles duplicate values in either list. All values will be unique in the resulting list.</p></li><li><p>Complexity is O( (#listA + #listB) * log( (#listA + #listB) ) )</p></li><li><p>You might want to consider using <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.SetFromList" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,160);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >SetFromList</a> combined with <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.UnionByKey" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,148);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >UnionByKey</a> for large tables or if you plan on doing this often.</p></li></ul></div>
</div>

<a name="TableX.IntersectionByKey"></a><a name="Topic151"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">IntersectionByKey</div>
 <div id="NDPrototype151" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@IntersectionByKey: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">tableA,</td></tr><tr><td class="PModifierQualifier first">tableB&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Gets the intersection of two tables by key.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">tableA</td><td class="CDLDefinition"><p>The first <b>table</b> in the intersection.</p></td></tr><tr><td class="CDLEntry">tableB</td><td class="CDLDefinition"><p>The second <b>table</b> in the intersection.</p></td></tr></table><div class="CHeading">Returns</div><p>The intersection <b>table</b>.</p><div class="CHeading">Example</div><p>:IntersectionByKey( { apple=&quot;red&quot;, pear=&quot;green&quot;, kiwi=&quot;hairy&quot; },</p><pre>{ apple=&quot;green&quot;, pear=&quot;green&quot;, banana=&quot;yellow&quot; } )</pre><p>returns...</p><p>:{ apple=&quot;green&quot;, pear=&quot;green&quot; }</p><div class="CHeading">Notes</div><ul><li><p>If both tables have values on the same key, tableB takes precedence.</p></li><li><p>Complexity is O(Count(tableA)).</p></li></ul></div>
</div>

<a name="TableX.IntersectionByKeyI"></a><a name="Topic152"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">IntersectionByKeyI</div>
 <div id="NDPrototype152" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@IntersectionByKeyI: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">tableA,</td></tr><tr><td class="PModifierQualifier first">tableB&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Exactly the same as <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.IntersectionByKey" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,151);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >IntersectionByKey</a> except that it uses fori instead of pairs. In general, this means that it only merges on numeric keys. See &lt;A Discussion On fori&gt;.</p></div>
</div>

<a name="TableX.Intersection"></a><a name="Topic153"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">Intersection</div>
 <div id="NDPrototype153" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@Intersection: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">listA,</td></tr><tr><td class="first"></td><td></td><td class="PName last">listB,</td></tr><tr><td class="PModifierQualifier first">inPlace&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Gets the intersection of two lists by value.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">listA</td><td class="CDLDefinition"><p>The first <b>list</b> in the intersection.</p></td></tr><tr><td class="CDLEntry">listB</td><td class="CDLDefinition"><p>The second <b>list</b> in the intersection.</p></td></tr><tr><td class="CDLEntry">inPlace</td><td class="CDLDefinition"><p>An <b>optional boolean</b>, defaults to <u>false</u>. If true, all operations occur on listA itself, rather than a copy.</p></td></tr></table><div class="CHeading">Returns</div><p>The intersection <b>list</b>. Returns tableA if inPlace is true, a new table otherwise.</p><div class="CHeading">Example</div><p>:Intersection( { &quot;apple&quot;, &quot;pear&quot;, &quot;kiwi&quot; }, { &quot;pear&quot;, &quot;apple&quot;, &quot;banana&quot; } )</p><p>returns...&nbsp; :{ &quot;apple&quot;, &quot;pear&quot; }</p><div class="CHeading">Notes</div><ul><li><p>This function operates over numeric indices. See &lt;A Discussion On fori&gt;.</p></li><li><p>The elements that are left in the returned table are in the same order they were in listA. See example above.</p></li><li><p>This function properly handles duplicate values in either list. All values will be unique in the resulting list.</p></li><li><p>Complexity is O(#ListA * #ListB).</p></li><li><p>You might want to consider using <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.SetFromList" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,160);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >SetFromList</a> combined with <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.IntersectionByKey" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,151);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >IntersectionByKey</a> for large tables or if you plan on doing this often.</p></li></ul></div>
</div>

<a name="TableX.DifferenceByKey"></a><a name="Topic154"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">DifferenceByKey</div>
 <div id="NDPrototype154" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@DifferenceByKey: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">tableA,</td></tr><tr><td class="first"></td><td></td><td class="PName last">tableB,</td></tr><tr><td class="PModifierQualifier first">inPlace&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Gets the difference of two tables by key. Difference is defined as all the keys in table A that are not in table B.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">tableA</td><td class="CDLDefinition"><p>The first <b>table</b> in the difference.</p></td></tr><tr><td class="CDLEntry">tableB</td><td class="CDLDefinition"><p>The second <b>table</b> in the difference.</p></td></tr><tr><td class="CDLEntry">inPlace</td><td class="CDLDefinition"><p>An <b>optional boolean</b>, defaults to <u>false</u>. If true, all operations occur on tableA itself, rather than a copy.</p></td></tr></table><div class="CHeading">Returns</div><p>The difference <b>table</b>. Returns tableA if inPlace is true, a new table otherwise.</p><div class="CHeading">Example</div><p>:DifferenceByKey( { apple=&quot;red&quot;, pear=&quot;green&quot;, kiwi=&quot;hairy&quot; },</p><pre>{ apple=&quot;green&quot;, pear=&quot;green&quot;, banana=&quot;yellow&quot; } )</pre><p>returns...</p><p>:{ kiwi=&quot;hairy&quot; }</p><div class="CHeading">Notes</div><ul><li><p>Complexity is O(Count(tableB)).</p></li></ul></div>
</div>

<a name="TableX.DifferenceByKeyI"></a><a name="Topic155"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">DifferenceByKeyI</div>
 <div id="NDPrototype155" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@DifferenceByKeyI: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">tableA,</td></tr><tr><td class="first"></td><td></td><td class="PName last">tableB,</td></tr><tr><td class="PModifierQualifier first">inPlace&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Exactly the same as <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.DifferenceByKey" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,154);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >DifferenceByKey</a> except that it uses fori instead of pairs. In general, this means that it only performs the difference on numeric keys. See &lt;A Discussion On fori&gt;.</p></div>
</div>

<a name="TableX.Difference"></a><a name="Topic156"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">Difference</div>
 <div id="NDPrototype156" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@Difference: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">listA,</td></tr><tr><td class="first"></td><td></td><td class="PName last">listB,</td></tr><tr><td class="PModifierQualifier first">inPlace&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Gets the difference of two lists by value.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">listA</td><td class="CDLDefinition"><p>The first <b>list</b> in the difference.</p></td></tr><tr><td class="CDLEntry">listB</td><td class="CDLDefinition"><p>The second <b>list</b> in the difference.</p></td></tr><tr><td class="CDLEntry">inPlace</td><td class="CDLDefinition"><p>An <b>optional boolean</b>, defaults to <u>false</u>. If true, all operations occur on tableA itself, rather than a copy.</p></td></tr></table><div class="CHeading">Returns</div><p>The difference <b>list</b>. Returns tableA if inPlace is true, a new table otherwise.</p><div class="CHeading">Example</div><p>:Difference( { &quot;apple&quot;, &quot;pear&quot;, &quot;kiwi&quot; }, { &quot;pear&quot;, &quot;apple&quot;, &quot;banana&quot; } )</p><p>returns...</p><p>:{ &quot;kiwi&quot; }</p><div class="CHeading">Notes</div><ul><li><p>This function operates over numeric indices. See &lt;A Discussion On fori&gt;.</p></li><li><p>The elements that are left in the returned table are in the same order they were in tableA. See example above.</p></li><li><p>This function properly handles duplicate values in either list. All values will be unique in the resulting list.</p></li><li><p>Complexity is O(#listA * #listB).</p></li><li><p>You might want to consider using <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.SetFromList" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,160);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >SetFromList</a> combined with <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.DifferenceByKey" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,154);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >DifferenceByKey</a> for large tables or if you plan on doing this often.</p></li></ul></div>
</div>

<a name="TableX.Append"></a><a name="Topic157"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">Append</div>
 <div id="NDPrototype157" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@Append: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">listA,</td></tr><tr><td class="first"></td><td></td><td class="PName last">listB,</td></tr><tr><td class="PModifierQualifier first">inPlace&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Appends values with numeric keys from one table to another.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">listA</td><td class="CDLDefinition"><p>The first <b>list</b> in the append.</p></td></tr><tr><td class="CDLEntry">listB</td><td class="CDLDefinition"><p>The second <b>list</b> in the append.</p></td></tr><tr><td class="CDLEntry">inPlace</td><td class="CDLDefinition"><p>An <b>optional boolean</b>, defaults to <u>false</u>. If true, all operations occur on tableA itself, rather than a copy.</p></td></tr></table><div class="CHeading">Returns</div><p>The <b>list</b> result of appending tableB to tableA. Returns tableA if inPlace is true, a new table otherwise.</p><div class="CHeading">Example</div><p>:Append( { &quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;kiwi&quot; },</p><pre>{ &quot;orange&quot;, &quot;pear&quot;, &quot;apple&quot; } )</pre><p>returns...</p><p>:{ &quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;kiwi&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;apple&quot; }</p><div class="CHeading">Notes</div><ul><li><p>This function uses fori. See &lt;A Discussion On fori&gt;.</p></li><li><p>Complexity is O(#listB).</p></li></ul></div>
</div>

<a name="TableX.HasValue"></a><a name="Topic158"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">HasValue</div>
 <div id="NDPrototype158" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@HasValue: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">t,</td></tr><tr><td class="PModifierQualifier first">value&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Checks for the presence of a value in a table.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">t</td><td class="CDLDefinition"><p>The <b>table</b> to check for the value's presence within.</p></td></tr><tr><td class="CDLEntry">value</td><td class="CDLDefinition"><p><b>Any type</b>, the value to check for within t.</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>A <b>boolean</b>. True if the table has the value, false otherwise.</p></td></tr><tr><td class="CDLEntry">2</td><td class="CDLDefinition"><p>A value of <b>any type</b>. The first key the value was found under if it was found, nil otherwise.</p></td></tr></table><div class="CHeading">Example</div><p>:HasValue( { apple=&quot;red&quot;, pear=&quot;green&quot;, kiwi=&quot;hairy&quot; }, &quot;green&quot; )</p><p>returns...</p><p>:true, &quot;pear&quot;</p></div>
</div>

<a name="TableX.HasValueI"></a><a name="Topic159"></a><div class="CTopic TFunction LMoonScript">
 <div class="CTitle">HasValueI</div>
 <div id="NDPrototype159" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@HasValueI: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td></td><td class="PName last">t,</td></tr><tr><td class="PModifierQualifier first">value&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Exactly the same as <a href="../../../index.html#File:moon/ulx/sh_tablex.moon:TableX.HasValue" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,158);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >HasValue</a> except that it uses fori instead of pairs.&nbsp; In general, this means that it only checks numeric keys. See &lt;A Discussion On fori&gt;.</p></div>
</div>

<a name="TableX.SetFromList"></a><a name="Topic160"></a><div class="CTopic TFunction LMoonScript last">
 <div class="CTitle">SetFromList</div>
 <div id="NDPrototype160" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">@SetFromList: (</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">list&nbsp;</td><td class="PType"><span class="SHKeyword">using</span>&nbsp;</td><td class="PName last">nil</td></tr></table></td><td class="PAfterParameters">) -&gt;</td></tr></table></div>
 <div class="CBody"><p>Creates a set from a list. A list is defined as a table with all numeric keys in sequential order (such as {&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;}).&nbsp; A set is defined as a table that only uses the boolean value true for keys that exist in the table.&nbsp; This function takes the values from the list and makes them the keys in a set, all with the value of 'true'.&nbsp; Note that you lose ordering and duplicates in the list during this conversion, but gain ease of testing for a value's existence in the table.&nbsp; One simply needs to test whether the value of a key is true or nil.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">list</td><td class="CDLDefinition"><p>The <b>list</b>.</p></td></tr></table><div class="CHeading">Returns</div><p>The <b>table</b> representing the set.</p><div class="CHeading">Example</div><p>:SetFromList( { &quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;, &quot;pear&quot; } )</p><p>returns...</p><p>:{ apple=true, banana=true, kiwi=true, pear=true }</p><div class="CHeading">Notes</div><ul><li><p>This function uses fori during the conversion process. See &lt;A Discussion On fori&gt;.</p></li><li><p>Complexity is O(#list).</p></li></ul></div>
</div>

</body></html>